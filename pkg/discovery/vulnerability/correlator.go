package vulnerability

import (
	"context"
	"fmt"
	"regexp"
	"strings"
	"time"

	"github.com/CodeMonkeyCybersecurity/shells/internal/logger"
)

// VulnerabilityCorrelator correlates discovered assets with potential vulnerabilities
type VulnerabilityCorrelator struct {
	logger          *logger.Logger
	vulnerabilities map[string]VulnerabilitySignature
	cvePatterns     map[string]*regexp.Regexp
}

// VulnerabilitySignature defines patterns for detecting vulnerabilities
type VulnerabilitySignature struct {
	ID          string
	Name        string
	Description string
	Severity    string
	Category    string
	Indicators  []Indicator
	References  []string
	CVSS        float64
}

// Indicator represents a vulnerability indicator
type Indicator struct {
	Type    string // service, version, header, banner, technology
	Pattern string
	Version string
}

// VulnerabilityFinding represents a discovered vulnerability
type VulnerabilityFinding struct {
	AssetID       string
	AssetValue    string
	Vulnerability VulnerabilitySignature
	Evidence      []string
	Confidence    float64
	DiscoveredAt  time.Time
}

// NewVulnerabilityCorrelator creates a new vulnerability correlator
func NewVulnerabilityCorrelator(logger *logger.Logger) *VulnerabilityCorrelator {
	correlator := &VulnerabilityCorrelator{
		logger:          logger,
		vulnerabilities: make(map[string]VulnerabilitySignature),
		cvePatterns:     make(map[string]*regexp.Regexp),
	}

	// Load vulnerability signatures
	correlator.loadVulnerabilitySignatures()

	return correlator
}

// loadVulnerabilitySignatures loads known vulnerability patterns
func (v *VulnerabilityCorrelator) loadVulnerabilitySignatures() {
	v.vulnerabilities = map[string]VulnerabilitySignature{
		// Web Server Vulnerabilities
		"apache-log4j": {
			ID:          "CVE-2021-44228",
			Name:        "Apache Log4j RCE (Log4Shell)",
			Description: "Remote code execution vulnerability in Apache Log4j",
			Severity:    "CRITICAL",
			Category:    "RCE",
			CVSS:        10.0,
			Indicators: []Indicator{
				{Type: "technology", Pattern: "log4j", Version: "2.0-2.14.1"},
				{Type: "header", Pattern: "X-Log4j-Version"},
			},
			References: []string{"https://nvd.nist.gov/vuln/detail/CVE-2021-44228"},
		},
		"apache-struts": {
			ID:          "CVE-2017-5638",
			Name:        "Apache Struts RCE",
			Description: "Remote code execution via Content-Type header",
			Severity:    "CRITICAL",
			Category:    "RCE",
			CVSS:        10.0,
			Indicators: []Indicator{
				{Type: "technology", Pattern: "struts", Version: "2.3.5-2.3.31,2.5-2.5.10"},
				{Type: "header", Pattern: "Struts"},
			},
			References: []string{"https://nvd.nist.gov/vuln/detail/CVE-2017-5638"},
		},
		"nginx-path-traversal": {
			ID:          "CVE-2021-23017",
			Name:        "nginx Path Traversal",
			Description: "Path traversal vulnerability in nginx",
			Severity:    "HIGH",
			Category:    "Path Traversal",
			CVSS:        7.5,
			Indicators: []Indicator{
				{Type: "service", Pattern: "nginx", Version: "0.6.18-1.20.0"},
				{Type: "banner", Pattern: "nginx/1\\.(19|20\\.0)"},
			},
			References: []string{"https://nvd.nist.gov/vuln/detail/CVE-2021-23017"},
		},

		// Database Vulnerabilities
		"mysql-auth-bypass": {
			ID:          "CVE-2012-2122",
			Name:        "MySQL Authentication Bypass",
			Description: "Authentication bypass in MySQL/MariaDB",
			Severity:    "HIGH",
			Category:    "Authentication Bypass",
			CVSS:        7.5,
			Indicators: []Indicator{
				{Type: "service", Pattern: "mysql", Version: "5.1.0-5.1.61,5.5.0-5.5.22"},
				{Type: "banner", Pattern: "5\\.(1\\.[0-5][0-9]|1\\.6[01]|5\\.[0-1][0-9]|5\\.2[0-2])"},
			},
			References: []string{"https://nvd.nist.gov/vuln/detail/CVE-2012-2122"},
		},
		"mongodb-noauth": {
			ID:          "MONGODB-NOAUTH",
			Name:        "MongoDB No Authentication",
			Description: "MongoDB instance with no authentication enabled",
			Severity:    "CRITICAL",
			Category:    "Misconfiguration",
			CVSS:        9.8,
			Indicators: []Indicator{
				{Type: "service", Pattern: "mongodb"},
				{Type: "banner", Pattern: "MongoDB"},
			},
			References: []string{"https://docs.mongodb.com/manual/administration/security-checklist/"},
		},
		"redis-noauth": {
			ID:          "REDIS-NOAUTH",
			Name:        "Redis No Authentication",
			Description: "Redis instance with no authentication enabled",
			Severity:    "HIGH",
			Category:    "Misconfiguration",
			CVSS:        7.5,
			Indicators: []Indicator{
				{Type: "service", Pattern: "redis"},
				{Type: "banner", Pattern: "Redis"},
			},
			References: []string{"https://redis.io/topics/security"},
		},

		// CMS Vulnerabilities
		"wordpress-xmlrpc": {
			ID:          "WP-XMLRPC",
			Name:        "WordPress XML-RPC Enabled",
			Description: "WordPress XML-RPC can be used for amplification attacks",
			Severity:    "MEDIUM",
			Category:    "Misconfiguration",
			CVSS:        5.3,
			Indicators: []Indicator{
				{Type: "technology", Pattern: "wordpress"},
				{Type: "header", Pattern: "X-Pingback"},
			},
			References: []string{"https://blog.sucuri.net/2015/10/brute-force-amplification-attacks-against-wordpress-xmlrpc.html"},
		},
		"drupal-drupalgeddon": {
			ID:          "CVE-2018-7600",
			Name:        "Drupalgeddon 2",
			Description: "Remote code execution in Drupal",
			Severity:    "CRITICAL",
			Category:    "RCE",
			CVSS:        9.8,
			Indicators: []Indicator{
				{Type: "technology", Pattern: "drupal", Version: "7.0-7.57,8.0-8.3.8,8.4.0-8.4.5,8.5.0"},
				{Type: "header", Pattern: "X-Drupal"},
			},
			References: []string{"https://nvd.nist.gov/vuln/detail/CVE-2018-7600"},
		},

		// Service Vulnerabilities
		"ssh-weak-ciphers": {
			ID:          "SSH-WEAK-CIPHERS",
			Name:        "SSH Weak Ciphers",
			Description: "SSH server supports weak encryption ciphers",
			Severity:    "MEDIUM",
			Category:    "Weak Cryptography",
			CVSS:        5.3,
			Indicators: []Indicator{
				{Type: "service", Pattern: "ssh"},
				{Type: "banner", Pattern: "OpenSSH_[1-6]"},
			},
			References: []string{"https://www.ssh.com/ssh/sshd_config"},
		},
		"ssl-heartbleed": {
			ID:          "CVE-2014-0160",
			Name:        "Heartbleed",
			Description: "OpenSSL heartbeat extension vulnerability",
			Severity:    "HIGH",
			Category:    "Information Disclosure",
			CVSS:        7.5,
			Indicators: []Indicator{
				{Type: "technology", Pattern: "openssl", Version: "1.0.1-1.0.1f"},
			},
			References: []string{"https://nvd.nist.gov/vuln/detail/CVE-2014-0160"},
		},
		"rdp-bluekeep": {
			ID:          "CVE-2019-0708",
			Name:        "BlueKeep",
			Description: "Remote Desktop Services Remote Code Execution",
			Severity:    "CRITICAL",
			Category:    "RCE",
			CVSS:        9.8,
			Indicators: []Indicator{
				{Type: "service", Pattern: "ms-wbt-server"},
			},
			References: []string{"https://nvd.nist.gov/vuln/detail/CVE-2019-0708"},
		},

		// Application Vulnerabilities
		"apache-tomcat-ghostcat": {
			ID:          "CVE-2020-1938",
			Name:        "Ghostcat",
			Description: "Apache Tomcat AJP Request Injection",
			Severity:    "HIGH",
			Category:    "Information Disclosure",
			CVSS:        7.5,
			Indicators: []Indicator{
				{Type: "technology", Pattern: "tomcat", Version: "6.0.0-6.0.53,7.0.0-7.0.99,8.0.0-8.5.50,9.0.0-9.0.30"},
				{Type: "service", Pattern: "ajp13"},
			},
			References: []string{"https://nvd.nist.gov/vuln/detail/CVE-2020-1938"},
		},
		"jenkins-rce": {
			ID:          "CVE-2017-1000353",
			Name:        "Jenkins Java Deserialization RCE",
			Description: "Remote code execution via Java deserialization",
			Severity:    "CRITICAL",
			Category:    "RCE",
			CVSS:        9.8,
			Indicators: []Indicator{
				{Type: "technology", Pattern: "jenkins", Version: "0-2.56"},
				{Type: "header", Pattern: "X-Jenkins"},
			},
			References: []string{"https://nvd.nist.gov/vuln/detail/CVE-2017-1000353"},
		},

		// Cloud Vulnerabilities
		"s3-public-read": {
			ID:          "S3-PUBLIC-READ",
			Name:        "S3 Bucket Public Read",
			Description: "S3 bucket allows public read access",
			Severity:    "HIGH",
			Category:    "Misconfiguration",
			CVSS:        7.5,
			Indicators: []Indicator{
				{Type: "technology", Pattern: "s3"},
			},
			References: []string{"https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-control-block-public-access.html"},
		},
		"azure-storage-public": {
			ID:          "AZURE-STORAGE-PUBLIC",
			Name:        "Azure Storage Public Access",
			Description: "Azure storage container allows public access",
			Severity:    "HIGH",
			Category:    "Misconfiguration",
			CVSS:        7.5,
			Indicators: []Indicator{
				{Type: "technology", Pattern: "azure-storage"},
			},
			References: []string{"https://docs.microsoft.com/en-us/azure/storage/blobs/anonymous-read-access-prevent"},
		},
	}

	// Compile regex patterns
	for _, vuln := range v.vulnerabilities {
		for _, indicator := range vuln.Indicators {
			if indicator.Type == "banner" || indicator.Type == "header" {
				v.cvePatterns[vuln.ID+"-"+indicator.Pattern] = regexp.MustCompile(indicator.Pattern)
			}
		}
	}
}

// CorrelateAsset checks an asset for vulnerabilities
func (v *VulnerabilityCorrelator) CorrelateAsset(asset interface{}) ([]*VulnerabilityFinding, error) {
	var findings []*VulnerabilityFinding

	// Extract asset information based on type
	assetInfo := v.extractAssetInfo(asset)
	if assetInfo == nil {
		return findings, nil
	}

	// Check each vulnerability signature
	for _, vuln := range v.vulnerabilities {
		if finding := v.checkVulnerability(assetInfo, vuln); finding != nil {
			findings = append(findings, finding)
		}
	}

	return findings, nil
}

// BulkCorrelate checks multiple assets for vulnerabilities
func (v *VulnerabilityCorrelator) BulkCorrelate(ctx context.Context, assets []interface{}) ([]*VulnerabilityFinding, error) {
	var allFindings []*VulnerabilityFinding

	for _, asset := range assets {
		select {
		case <-ctx.Done():
			return allFindings, ctx.Err()
		default:
			findings, err := v.CorrelateAsset(asset)
			if err != nil {
				v.logger.Error("Failed to correlate asset", "error", err)
				continue
			}
			allFindings = append(allFindings, findings...)
		}
	}

	v.logger.Info("Vulnerability correlation completed",
		"assets_checked", len(assets),
		"vulnerabilities_found", len(allFindings))

	return allFindings, nil
}

// AssetInfo represents extracted asset information
type AssetInfo struct {
	ID         string
	Value      string
	Type       string
	Service    string
	Version    string
	Technology []string
	Headers    map[string]string
	Banner     string
	Port       int
	IsPublic   bool
}

// extractAssetInfo extracts relevant information from an asset
func (v *VulnerabilityCorrelator) extractAssetInfo(asset interface{}) *AssetInfo {
	info := &AssetInfo{
		Headers: make(map[string]string),
	}

	// Type assertion for Asset structure
	// Note: This assumes the asset structure from the discovery module
	// You may need to adjust based on your actual Asset type
	if assetMap, ok := asset.(map[string]interface{}); ok {
		// Extract basic fields
		if id, ok := assetMap["ID"].(string); ok {
			info.ID = id
		}
		if value, ok := assetMap["Value"].(string); ok {
			info.Value = value
		}
		if assetType, ok := assetMap["Type"].(string); ok {
			info.Type = assetType
		}
		if port, ok := assetMap["Port"].(int); ok {
			info.Port = port
		}

		// Extract from metadata
		if metadata, ok := assetMap["Metadata"].(map[string]string); ok {
			if service, exists := metadata["service"]; exists {
				info.Service = service
			}
			if banner, exists := metadata["banner"]; exists {
				info.Banner = banner
			}
			if version, exists := metadata["version"]; exists {
				info.Version = version
			}
			if public, exists := metadata["public"]; exists && public == "true" {
				info.IsPublic = true
			}
		}

		// Extract technology
		if tech, ok := assetMap["Technology"].([]string); ok {
			info.Technology = tech
		}

		// For web assets, extract headers if available
		if info.Type == "url" || info.Type == "endpoint" {
			// Headers would be populated during web crawling
			// This is a placeholder for when headers are available
		}
	}

	// Direct type assertion if asset is already the correct type
	type ConcreteAsset struct {
		ID         string
		Type       string
		Value      string
		Port       int
		Technology []string
		Metadata   map[string]string
	}

	if concreteAsset, ok := asset.(*ConcreteAsset); ok {
		info.ID = concreteAsset.ID
		info.Type = concreteAsset.Type
		info.Value = concreteAsset.Value
		info.Port = concreteAsset.Port
		info.Technology = concreteAsset.Technology

		if concreteAsset.Metadata != nil {
			if service, exists := concreteAsset.Metadata["service"]; exists {
				info.Service = service
			}
			if banner, exists := concreteAsset.Metadata["banner"]; exists {
				info.Banner = banner
			}
			if version, exists := concreteAsset.Metadata["version"]; exists {
				info.Version = version
			}
			if public, exists := concreteAsset.Metadata["public"]; exists && public == "true" {
				info.IsPublic = true
			}
		}
	}

	return info
}

// checkVulnerability checks if an asset matches a vulnerability signature
func (v *VulnerabilityCorrelator) checkVulnerability(asset *AssetInfo, vuln VulnerabilitySignature) *VulnerabilityFinding {
	var evidence []string
	matched := false
	confidence := 0.0

	for _, indicator := range vuln.Indicators {
		switch indicator.Type {
		case "service":
			if strings.Contains(strings.ToLower(asset.Service), indicator.Pattern) {
				matched = true
				confidence += 0.3
				evidence = append(evidence, fmt.Sprintf("Service matches: %s", indicator.Pattern))

				// Check version if specified
				if indicator.Version != "" && asset.Version != "" {
					if v.versionInRange(asset.Version, indicator.Version) {
						confidence += 0.4
						evidence = append(evidence, fmt.Sprintf("Version in vulnerable range: %s", indicator.Version))
					}
				}
			}

		case "technology":
			for _, tech := range asset.Technology {
				if strings.Contains(strings.ToLower(tech), indicator.Pattern) {
					matched = true
					confidence += 0.3
					evidence = append(evidence, fmt.Sprintf("Technology matches: %s", indicator.Pattern))

					// Version check for technology
					if indicator.Version != "" {
						// Extract version from technology string and check
						confidence += 0.3
					}
				}
			}

		case "banner":
			if asset.Banner != "" {
				if pattern, exists := v.cvePatterns[vuln.ID+"-"+indicator.Pattern]; exists {
					if pattern.MatchString(asset.Banner) {
						matched = true
						confidence += 0.5
						evidence = append(evidence, fmt.Sprintf("Banner matches pattern: %s", indicator.Pattern))
					}
				}
			}

		case "header":
			for key, value := range asset.Headers {
				if strings.Contains(strings.ToLower(key), strings.ToLower(indicator.Pattern)) ||
					strings.Contains(strings.ToLower(value), strings.ToLower(indicator.Pattern)) {
					matched = true
					confidence += 0.4
					evidence = append(evidence, fmt.Sprintf("Header matches: %s", indicator.Pattern))
				}
			}
		}
	}

	// Special checks for misconfigurations
	if vuln.Category == "Misconfiguration" {
		switch vuln.ID {
		case "S3-PUBLIC-READ", "AZURE-STORAGE-PUBLIC":
			if asset.IsPublic {
				matched = true
				confidence = 0.9
				evidence = append(evidence, "Resource is publicly accessible")
			}
		case "MONGODB-NOAUTH", "REDIS-NOAUTH":
			// These would require active probing to confirm
			if matched {
				confidence = 0.7
				evidence = append(evidence, "Service appears to be exposed, authentication status unknown")
			}
		}
	}

	if matched && confidence > 0.5 {
		return &VulnerabilityFinding{
			AssetID:       asset.ID,
			AssetValue:    asset.Value,
			Vulnerability: vuln,
			Evidence:      evidence,
			Confidence:    confidence,
			DiscoveredAt:  time.Now(),
		}
	}

	return nil
}

// versionInRange checks if a version is within a vulnerable range
func (v *VulnerabilityCorrelator) versionInRange(version, versionRange string) bool {
	// Simplified version checking - in production, use proper version comparison
	// Version range format: "1.0.0-1.0.5,2.0.0-2.0.3"

	ranges := strings.Split(versionRange, ",")
	for _, r := range ranges {
		parts := strings.Split(r, "-")
		if len(parts) == 2 {
			// Simple string comparison - should use proper version comparison
			if version >= parts[0] && version <= parts[1] {
				return true
			}
		}
	}

	return false
}

// GetVulnerabilityStats returns statistics about known vulnerabilities
func (v *VulnerabilityCorrelator) GetVulnerabilityStats() map[string]int {
	stats := map[string]int{
		"total":    len(v.vulnerabilities),
		"critical": 0,
		"high":     0,
		"medium":   0,
		"low":      0,
	}

	for _, vuln := range v.vulnerabilities {
		switch strings.ToUpper(vuln.Severity) {
		case "CRITICAL":
			stats["critical"]++
		case "HIGH":
			stats["high"]++
		case "MEDIUM":
			stats["medium"]++
		case "LOW":
			stats["low"]++
		}
	}

	return stats
}
