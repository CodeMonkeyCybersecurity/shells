// pkg/correlation/exploit_chainer.go
package correlation

import (
	"fmt"
	"strings"

	"github.com/CodeMonkeyCybersecurity/shells/pkg/types"
	"go.uber.org/zap"
)

// ExploitChainer identifies and chains vulnerabilities to create attack paths
type ExploitChainer struct {
	logger *zap.Logger
}

// NewExploitChainer creates a new exploit chainer
func NewExploitChainer() *ExploitChainer {
	logger, _ := zap.NewProduction()
	return &ExploitChainer{
		logger: logger,
	}
}

// BuildAttackGraph creates a graph of potential attack paths
func (ec *ExploitChainer) BuildAttackGraph(findings []types.Finding) AttackGraph {
	graph := AttackGraph{
		Nodes: make(map[string]AttackNode),
		Edges: []AttackEdge{},
	}

	// Create nodes for each finding
	for _, finding := range findings {
		node := AttackNode{
			ID:         finding.ID,
			Type:       ec.classifyAttackType(finding),
			Finding:    finding,
			Severity:   finding.Severity,
			Capability: ec.extractCapability(finding),
			Access:     ec.extractAccessLevel(finding),
			Targets:    ec.extractTargets(finding),
		}
		graph.Nodes[finding.ID] = node
	}

	// Create edges for potential chains
	for sourceID, sourceNode := range graph.Nodes {
		for targetID, targetNode := range graph.Nodes {
			if sourceID != targetID {
				if edge := ec.canChain(sourceNode, targetNode); edge != nil {
					edge.Source = sourceID
					edge.Target = targetID
					graph.Edges = append(graph.Edges, *edge)
				}
			}
		}
	}

	ec.logger.Info("Attack graph built",
		zap.Int("nodes", len(graph.Nodes)),
		zap.Int("edges", len(graph.Edges)))

	return graph
}

// FindAttackPaths discovers viable attack paths in the graph
func (ec *ExploitChainer) FindAttackPaths(graph AttackGraph) []AttackPath {
	var paths []AttackPath

	// Find all entry points (externally accessible nodes)
	entryPoints := ec.findEntryPoints(graph)

	// Find all high-value targets
	targets := ec.findHighValueTargets(graph)

	// For each entry point, find paths to targets
	for _, entry := range entryPoints {
		for _, target := range targets {
			if entry.ID != target.ID {
				foundPaths := ec.findPathsBetweenNodes(graph, entry, target, 5) // Max depth 5
				paths = append(paths, foundPaths...)
			}
		}
	}

	// Score and filter paths
	scoredPaths := ec.scoreAttackPaths(paths)

	ec.logger.Info("Attack paths found",
		zap.Int("total_paths", len(paths)),
		zap.Int("scored_paths", len(scoredPaths)))

	return scoredPaths
}

// classifyAttackType determines the type of attack a finding represents
func (ec *ExploitChainer) classifyAttackType(finding types.Finding) AttackType {
	content := strings.ToLower(finding.Type + " " + finding.Description)

	// Reconnaissance
	if strings.Contains(content, "discovery") || strings.Contains(content, "enum") ||
		strings.Contains(content, "scan") || strings.Contains(content, "info") {
		return AttackTypeReconnaissance
	}

	// Initial Access
	if strings.Contains(content, "exposed") || strings.Contains(content, "public") ||
		strings.Contains(content, "unauthenticated") || strings.Contains(content, "anonymous") {
		return AttackTypeInitialAccess
	}

	// Persistence
	if strings.Contains(content, "backdoor") || strings.Contains(content, "persistence") ||
		strings.Contains(content, "cron") || strings.Contains(content, "service") {
		return AttackTypePersistence
	}

	// Privilege Escalation
	if strings.Contains(content, "privilege") || strings.Contains(content, "escalation") ||
		strings.Contains(content, "admin") || strings.Contains(content, "root") {
		return AttackTypePrivilegeEscalation
	}

	// Defense Evasion
	if strings.Contains(content, "bypass") || strings.Contains(content, "evasion") ||
		strings.Contains(content, "disable") || strings.Contains(content, "hide") {
		return AttackTypeDefenseEvasion
	}

	// Credential Access
	if strings.Contains(content, "credential") || strings.Contains(content, "password") ||
		strings.Contains(content, "hash") || strings.Contains(content, "token") {
		return AttackTypeCredentialAccess
	}

	// Discovery
	if strings.Contains(content, "network") || strings.Contains(content, "host") ||
		strings.Contains(content, "service") || strings.Contains(content, "file") {
		return AttackTypeDiscovery
	}

	// Lateral Movement
	if strings.Contains(content, "lateral") || strings.Contains(content, "pivot") ||
		strings.Contains(content, "ssh") || strings.Contains(content, "rdp") {
		return AttackTypeLateralMovement
	}

	// Collection
	if strings.Contains(content, "data") || strings.Contains(content, "file") ||
		strings.Contains(content, "database") || strings.Contains(content, "backup") {
		return AttackTypeCollection
	}

	// Exfiltration
	if strings.Contains(content, "exfil") || strings.Contains(content, "download") ||
		strings.Contains(content, "upload") || strings.Contains(content, "transfer") {
		return AttackTypeExfiltration
	}

	// Impact
	if strings.Contains(content, "dos") || strings.Contains(content, "denial") ||
		strings.Contains(content, "destroy") || strings.Contains(content, "wipe") {
		return AttackTypeImpact
	}

	return AttackTypeUnknown
}

// extractCapability determines what capabilities this finding provides
func (ec *ExploitChainer) extractCapability(finding types.Finding) []string {
	var capabilities []string
	content := strings.ToLower(finding.Type + " " + finding.Description + " " + finding.Evidence)

	if strings.Contains(content, "rce") || strings.Contains(content, "code execution") {
		capabilities = append(capabilities, "code_execution")
	}
	if strings.Contains(content, "file") && (strings.Contains(content, "read") || strings.Contains(content, "access")) {
		capabilities = append(capabilities, "file_read")
	}
	if strings.Contains(content, "file") && strings.Contains(content, "write") {
		capabilities = append(capabilities, "file_write")
	}
	if strings.Contains(content, "sql") || strings.Contains(content, "database") {
		capabilities = append(capabilities, "database_access")
	}
	if strings.Contains(content, "network") || strings.Contains(content, "scan") {
		capabilities = append(capabilities, "network_access")
	}
	if strings.Contains(content, "credential") || strings.Contains(content, "password") {
		capabilities = append(capabilities, "credential_access")
	}
	if strings.Contains(content, "admin") || strings.Contains(content, "root") {
		capabilities = append(capabilities, "admin_access")
	}

	return capabilities
}

// extractAccessLevel determines the access level this finding provides
func (ec *ExploitChainer) extractAccessLevel(finding types.Finding) AccessLevel {
	content := strings.ToLower(finding.Type + " " + finding.Description)

	if strings.Contains(content, "unauthenticated") || strings.Contains(content, "anonymous") ||
		strings.Contains(content, "public") {
		return AccessLevelPublic
	}
	if strings.Contains(content, "user") || strings.Contains(content, "authenticated") {
		return AccessLevelUser
	}
	if strings.Contains(content, "admin") || strings.Contains(content, "privileged") {
		return AccessLevelAdmin
	}
	if strings.Contains(content, "root") || strings.Contains(content, "system") {
		return AccessLevelSystem
	}

	return AccessLevelUnknown
}

// extractTargets identifies what this finding can target
func (ec *ExploitChainer) extractTargets(finding types.Finding) []string {
	var targets []string

	if domain, ok := finding.Metadata["domain"].(string); ok {
		targets = append(targets, "domain:"+domain)
	}
	if ip, ok := finding.Metadata["ip"].(string); ok {
		targets = append(targets, "ip:"+ip)
	}
	if service, ok := finding.Metadata["service"].(string); ok {
		targets = append(targets, "service:"+service)
	}
	if port, ok := finding.Metadata["port"].(string); ok {
		targets = append(targets, "port:"+port)
	}

	return targets
}

// canChain determines if two attack nodes can be chained together
func (ec *ExploitChainer) canChain(source, target AttackNode) *AttackEdge {
	// Check if source provides capabilities that target requires
	chainWeight := 0.0
	chainType := ""

	// Sequential attack types (MITRE ATT&CK style)
	sequentialChains := map[AttackType][]AttackType{
		AttackTypeReconnaissance:      {AttackTypeInitialAccess},
		AttackTypeInitialAccess:       {AttackTypePersistence, AttackTypePrivilegeEscalation, AttackTypeCredentialAccess},
		AttackTypePersistence:         {AttackTypePrivilegeEscalation, AttackTypeDefenseEvasion},
		AttackTypePrivilegeEscalation: {AttackTypeDefenseEvasion, AttackTypeCredentialAccess, AttackTypeDiscovery},
		AttackTypeDefenseEvasion:      {AttackTypeCredentialAccess, AttackTypeDiscovery, AttackTypeLateralMovement},
		AttackTypeCredentialAccess:    {AttackTypeLateralMovement, AttackTypeDiscovery},
		AttackTypeDiscovery:           {AttackTypeLateralMovement, AttackTypeCollection},
		AttackTypeLateralMovement:     {AttackTypeCollection, AttackTypeCredentialAccess},
		AttackTypeCollection:          {AttackTypeExfiltration},
		AttackTypeExfiltration:        {AttackTypeImpact},
	}

	// Check for sequential chaining
	if validTargets, exists := sequentialChains[source.Type]; exists {
		for _, validTarget := range validTargets {
			if target.Type == validTarget {
				chainWeight += 0.8
				chainType = "sequential"
				break
			}
		}
	}

	// Check for capability-based chaining
	sourceCapabilities := source.Capability
	for _, capability := range sourceCapabilities {
		switch capability {
		case "code_execution":
			if target.Type == AttackTypePersistence || target.Type == AttackTypePrivilegeEscalation {
				chainWeight += 0.9
				chainType = "capability"
			}
		case "credential_access":
			if target.Type == AttackTypeLateralMovement || target.Type == AttackTypePrivilegeEscalation {
				chainWeight += 0.8
				chainType = "capability"
			}
		case "admin_access":
			if target.Type == AttackTypeCollection || target.Type == AttackTypeExfiltration {
				chainWeight += 0.9
				chainType = "capability"
			}
		case "network_access":
			if target.Type == AttackTypeDiscovery || target.Type == AttackTypeLateralMovement {
				chainWeight += 0.7
				chainType = "capability"
			}
		}
	}

	// Check for target overlap
	sourceTargets := source.Targets
	targetTargets := target.Targets
	for _, sourceTarget := range sourceTargets {
		for _, targetTarget := range targetTargets {
			if sourceTarget == targetTarget {
				chainWeight += 0.3
				if chainType == "" {
					chainType = "target_overlap"
				}
			}
		}
	}

	// Minimum weight threshold for viable chain
	if chainWeight < 0.3 {
		return nil
	}

	return &AttackEdge{
		Type:       chainType,
		Weight:     chainWeight,
		Confidence: ec.calculateChainConfidence(source, target, chainWeight),
	}
}

// calculateChainConfidence calculates confidence in the attack chain
func (ec *ExploitChainer) calculateChainConfidence(source, target AttackNode, baseWeight float64) float64 {
	confidence := baseWeight

	// Boost confidence for high severity findings
	if source.Severity == types.SeverityCritical {
		confidence += 0.2
	}
	if target.Severity == types.SeverityCritical {
		confidence += 0.2
	}

	// Reduce confidence for complex chains
	if source.Access == AccessLevelSystem && target.Access == AccessLevelPublic {
		confidence -= 0.3 // Unusual privilege downgrade
	}

	// Cap confidence
	if confidence > 1.0 {
		confidence = 1.0
	}
	if confidence < 0.0 {
		confidence = 0.0
	}

	return confidence
}

// findEntryPoints identifies nodes that can be accessed externally
func (ec *ExploitChainer) findEntryPoints(graph AttackGraph) []AttackNode {
	var entryPoints []AttackNode

	for _, node := range graph.Nodes {
		if ec.isEntryPoint(node) {
			entryPoints = append(entryPoints, node)
		}
	}

	return entryPoints
}

// findHighValueTargets identifies high-value target nodes
func (ec *ExploitChainer) findHighValueTargets(graph AttackGraph) []AttackNode {
	var targets []AttackNode

	for _, node := range graph.Nodes {
		if ec.isHighValueTarget(node) {
			targets = append(targets, node)
		}
	}

	return targets
}

// isEntryPoint determines if a node can be accessed externally
func (ec *ExploitChainer) isEntryPoint(node AttackNode) bool {
	// External access indicators
	if node.Access == AccessLevelPublic {
		return true
	}
	if node.Type == AttackTypeInitialAccess {
		return true
	}

	content := strings.ToLower(node.Finding.Description)
	entryKeywords := []string{"exposed", "public", "unauthenticated", "internet", "external"}
	for _, keyword := range entryKeywords {
		if strings.Contains(content, keyword) {
			return true
		}
	}

	return false
}

// isHighValueTarget determines if a node represents a high-value target
func (ec *ExploitChainer) isHighValueTarget(node AttackNode) bool {
	// High-value target indicators
	if node.Access == AccessLevelAdmin || node.Access == AccessLevelSystem {
		return true
	}
	if node.Type == AttackTypeCollection || node.Type == AttackTypeExfiltration {
		return true
	}

	content := strings.ToLower(node.Finding.Description)
	valueKeywords := []string{"admin", "root", "database", "credential", "payment", "customer"}
	for _, keyword := range valueKeywords {
		if strings.Contains(content, keyword) {
			return true
		}
	}

	return false
}

// findPathsBetweenNodes uses DFS to find paths between two nodes
func (ec *ExploitChainer) findPathsBetweenNodes(graph AttackGraph, start, end AttackNode, maxDepth int) []AttackPath {
	var paths []AttackPath
	visited := make(map[string]bool)
	currentPath := []AttackStep{}

	ec.dfsPath(graph, start.ID, end.ID, visited, currentPath, &paths, maxDepth, 0)

	return paths
}

// dfsPath performs depth-first search to find attack paths
func (ec *ExploitChainer) dfsPath(graph AttackGraph, current, target string, visited map[string]bool,
	currentPath []AttackStep, paths *[]AttackPath, maxDepth, currentDepth int) {

	if currentDepth > maxDepth {
		return
	}

	if current == target {
		// Found a path
		if len(currentPath) > 0 {
			path := AttackPath{
				Goal:       ec.generatePathGoal(currentPath),
				Steps:      make([]AttackStep, len(currentPath)),
				Confidence: ec.calculatePathConfidence(currentPath),
				Impact:     ec.calculatePathImpact(currentPath),
				Difficulty: ec.calculatePathDifficulty(currentPath),
			}
			copy(path.Steps, currentPath)
			*paths = append(*paths, path)
		}
		return
	}

	visited[current] = true

	// Find outgoing edges
	for _, edge := range graph.Edges {
		if edge.Source == current && !visited[edge.Target] {
			// Add step to current path
			step := AttackStep{
				Order:       len(currentPath) + 1,
				Description: ec.generateStepDescription(graph.Nodes[current], graph.Nodes[edge.Target]),
				Tool:        graph.Nodes[edge.Target].Finding.Tool,
				Confidence:  edge.Confidence,
				Evidence:    []Evidence{}, // Would populate with relevant evidence
			}

			newPath := append(currentPath, step)
			ec.dfsPath(graph, edge.Target, target, visited, newPath, paths, maxDepth, currentDepth+1)
		}
	}

	visited[current] = false
}

// scoreAttackPaths scores and filters attack paths
func (ec *ExploitChainer) scoreAttackPaths(paths []AttackPath) []AttackPath {
	var scoredPaths []AttackPath

	for _, path := range paths {
		// Only include paths with reasonable confidence
		if path.Confidence > 0.5 {
			scoredPaths = append(scoredPaths, path)
		}
	}

	return scoredPaths
}

// Helper methods for path analysis

func (ec *ExploitChainer) generatePathGoal(steps []AttackStep) string {
	if len(steps) == 0 {
		return "Unknown Goal"
	}

	lastStep := steps[len(steps)-1]
	return fmt.Sprintf("Achieve %s via %d-step attack chain", lastStep.Description, len(steps))
}

func (ec *ExploitChainer) calculatePathConfidence(steps []AttackStep) float64 {
	if len(steps) == 0 {
		return 0.0
	}

	totalConfidence := 0.0
	for _, step := range steps {
		totalConfidence += step.Confidence
	}

	// Average confidence, with penalty for longer chains
	avgConfidence := totalConfidence / float64(len(steps))
	lengthPenalty := float64(len(steps)) * 0.1
	finalConfidence := avgConfidence - lengthPenalty

	if finalConfidence < 0.0 {
		finalConfidence = 0.0
	}

	return finalConfidence
}

func (ec *ExploitChainer) calculatePathImpact(steps []AttackStep) string {
	if len(steps) == 0 {
		return "Low"
	}

	// Simplified impact calculation
	if len(steps) >= 4 {
		return "Critical"
	} else if len(steps) >= 2 {
		return "High"
	}
	return "Medium"
}

func (ec *ExploitChainer) calculatePathDifficulty(steps []AttackStep) string {
	if len(steps) == 0 {
		return "Unknown"
	}

	avgConfidence := ec.calculatePathConfidence(steps)
	if avgConfidence > 0.8 {
		return "Easy"
	} else if avgConfidence > 0.6 {
		return "Medium"
	}
	return "Hard"
}

func (ec *ExploitChainer) generateStepDescription(source, target AttackNode) string {
	return fmt.Sprintf("Use %s to enable %s", source.Finding.Type, target.Finding.Type)
}

// Supporting types

type AttackGraph struct {
	Nodes map[string]AttackNode
	Edges []AttackEdge
}

type AttackNode struct {
	ID         string
	Type       AttackType
	Finding    types.Finding
	Severity   types.Severity
	Capability []string
	Access     AccessLevel
	Targets    []string
}

type AttackEdge struct {
	Source     string
	Target     string
	Type       string
	Weight     float64
	Confidence float64
}

type AttackType string

const (
	AttackTypeReconnaissance      AttackType = "reconnaissance"
	AttackTypeInitialAccess       AttackType = "initial_access"
	AttackTypePersistence         AttackType = "persistence"
	AttackTypePrivilegeEscalation AttackType = "privilege_escalation"
	AttackTypeDefenseEvasion      AttackType = "defense_evasion"
	AttackTypeCredentialAccess    AttackType = "credential_access"
	AttackTypeDiscovery           AttackType = "discovery"
	AttackTypeLateralMovement     AttackType = "lateral_movement"
	AttackTypeCollection          AttackType = "collection"
	AttackTypeExfiltration        AttackType = "exfiltration"
	AttackTypeImpact              AttackType = "impact"
	AttackTypeUnknown             AttackType = "unknown"
)

type AccessLevel string

const (
	AccessLevelPublic  AccessLevel = "public"
	AccessLevelUser    AccessLevel = "user"
	AccessLevelAdmin   AccessLevel = "admin"
	AccessLevelSystem  AccessLevel = "system"
	AccessLevelUnknown AccessLevel = "unknown"
)
